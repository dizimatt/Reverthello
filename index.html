<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello / Reversi Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback } = React;

        const OthelloGame = () => {
          // Initialize 8x8 board with starting position
          const initializeBoard = () => {
            const board = Array(8).fill(null).map(() => Array(8).fill(null));
            board[3][3] = 'white';
            board[3][4] = 'black';
            board[4][3] = 'black';
            board[4][4] = 'white';
            return board;
          };

          const [board, setBoard] = useState(initializeBoard);
          const [currentPlayer, setCurrentPlayer] = useState('black'); // Black goes first
          const [validMoves, setValidMoves] = useState([]);
          const [gameOver, setGameOver] = useState(false);
          const [scores, setScores] = useState({ black: 2, white: 2 });
          const [apiKey, setApiKey] = useState('');
          const [useAI, setUseAI] = useState(false);
          const [aiThinking, setAiThinking] = useState(false);
          const [aiStatus, setAiStatus] = useState('disconnected'); // 'disconnected', 'connecting', 'connected', 'error'
          const [aiError, setAiError] = useState('');
          const [difficulty, setDifficulty] = useState('medium'); // 'easy', 'medium', 'hard', 'expert'

          // Directions for checking adjacent cells
          const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
          ];

          // Check if a move is valid and return pieces to flip
          const checkMove = useCallback((board, row, col, player) => {
            if (board[row][col] !== null) return [];
            
            const opponent = player === 'black' ? 'white' : 'black';
            const piecesToFlip = [];

            for (const [dr, dc] of directions) {
              const currentFlip = [];
              let r = row + dr;
              let c = col + dc;

              // Check if we can capture in this direction
              while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                currentFlip.push([r, c]);
                r += dr;
                c += dc;
              }

              // If we found opponent pieces and ended with our piece, this direction is valid
              if (currentFlip.length > 0 && r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
                piecesToFlip.push(...currentFlip);
              }
            }

            return piecesToFlip;
          }, []);

          // Find all valid moves for current player
          const findValidMoves = useCallback((board, player) => {
            const moves = [];
            for (let row = 0; row < 8; row++) {
              for (let col = 0; col < 8; col++) {
                if (checkMove(board, row, col, player).length > 0) {
                  moves.push([row, col]);
                }
              }
            }
            return moves;
          }, [checkMove]);

          // Calculate scores
          const calculateScores = useCallback((board) => {
            let black = 0, white = 0;
            for (let row = 0; row < 8; row++) {
              for (let col = 0; col < 8; col++) {
                if (board[row][col] === 'black') black++;
                else if (board[row][col] === 'white') white++;
              }
            }
            return { black, white };
          }, []);

          // Test API connection
          const testAPIConnection = useCallback(async () => {
            if (!apiKey) {
              setAiStatus('disconnected');
              return;
            }

            setAiStatus('connecting');
            setAiError('');

            try {
              const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': apiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-3-haiku-20240307',
                  max_tokens: 10,
                  messages: [{
                    role: 'user',
                    content: 'Test connection - just respond "OK"'
                  }]
                })
              });

              if (response.ok) {
                setAiStatus('connected');
                setAiError('');
              } else {
                const errorData = await response.json().catch(() => ({}));
                setAiStatus('error');
                setAiError(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
              }
            } catch (error) {
              setAiStatus('error');
              setAiError(error.message || 'Connection failed');
            }
          }, [apiKey]);

          // Make a move (for both human and AI)
          const makeMove = useCallback((row, col, player) => {
            const piecesToFlip = checkMove(board, row, col, player);
            if (piecesToFlip.length === 0) return false;

            // Make the move
            const newBoard = board.map(r => [...r]);
            newBoard[row][col] = player;
            
            // Flip captured pieces
            piecesToFlip.forEach(([r, c]) => {
              newBoard[r][c] = player;
            });

            setBoard(newBoard);
            setCurrentPlayer(player === 'black' ? 'white' : 'black');
            return true;
          }, [board, checkMove]);

          // Simple AI with difficulty levels
          const makeSimpleAIMove = useCallback(() => {
            const moves = findValidMoves(board, 'white');
            if (moves.length === 0) return;

            let bestMove = null;

            if (difficulty === 'easy') {
              // Easy: Random move with slight preference for corners
              const cornerMoves = moves.filter(([r, c]) => (r === 0 || r === 7) && (c === 0 || c === 7));
              if (cornerMoves.length > 0 && Math.random() < 0.7) {
                bestMove = cornerMoves[Math.floor(Math.random() * cornerMoves.length)];
              } else {
                bestMove = moves[Math.floor(Math.random() * moves.length)];
              }
            } else if (difficulty === 'medium') {
              // Medium: Basic strategy - corners > edges > captures
              let bestScore = -1;
              for (const [row, col] of moves) {
                let score = checkMove(board, row, col, 'white').length;
                
                if ((row === 0 || row === 7) && (col === 0 || col === 7)) {
                  score += 10; // Corner bonus
                } else if (row === 0 || row === 7 || col === 0 || col === 7) {
                  score += 2; // Edge bonus
                }
                
                if (score > bestScore) {
                  bestScore = score;
                  bestMove = [row, col];
                }
              }
            } else if (difficulty === 'hard') {
              // Hard: Advanced strategy with mobility and stability
              let bestScore = -1000;
              for (const [row, col] of moves) {
                let score = 0;
                
                // Simulate the move
                const newBoard = board.map(r => [...r]);
                const flipped = checkMove(board, row, col, 'white');
                newBoard[row][col] = 'white';
                flipped.forEach(([r, c]) => newBoard[r][c] = 'white');
                
                // Material count
                score += flipped.length;
                
                // Corner control (very important)
                if ((row === 0 || row === 7) && (col === 0 || col === 7)) {
                  score += 50;
                }
                
                // Avoid giving opponent corners
                const adjacentToCorner = [
                  [0,1], [1,0], [1,1], // near (0,0)
                  [0,6], [1,6], [1,7], // near (0,7)
                  [6,0], [6,1], [7,1], // near (7,0)
                  [6,6], [6,7], [7,6]  // near (7,7)
                ];
                if (adjacentToCorner.some(([r, c]) => r === row && c === col)) {
                  score -= 20;
                }
                
                // Mobility: count opponent's future moves
                const opponentMoves = findValidMoves(newBoard, 'black');
                score -= opponentMoves.length * 2;
                
                // Edge stability
                if (row === 0 || row === 7 || col === 0 || col === 7) {
                  score += 5;
                }
                
                if (score > bestScore) {
                  bestScore = score;
                  bestMove = [row, col];
                }
              }
            }

            if (bestMove) {
              setTimeout(() => {
                makeMove(bestMove[0], bestMove[1], 'white');
              }, 1000);
            }
          }, [board, findValidMoves, checkMove, makeMove, difficulty]);

          // AI move using Claude API
          const makeAIMove = useCallback(async () => {
            // Expert difficulty requires Claude AI
            if (difficulty === 'expert' && (!useAI || !apiKey || aiStatus !== 'connected')) {
              console.log('Expert difficulty requires Claude AI - falling back to hard difficulty');
              // Temporarily use hard difficulty logic
              const moves = findValidMoves(board, 'white');
              if (moves.length === 0) return;

              let bestMove = null;
              let bestScore = -1000;
              for (const [row, col] of moves) {
                let score = 0;
                const newBoard = board.map(r => [...r]);
                const flipped = checkMove(board, row, col, 'white');
                newBoard[row][col] = 'white';
                flipped.forEach(([r, c]) => newBoard[r][c] = 'white');
                
                score += flipped.length;
                if ((row === 0 || row === 7) && (col === 0 || col === 7)) score += 50;
                
                const adjacentToCorner = [[0,1], [1,0], [1,1], [0,6], [1,6], [1,7], [6,0], [6,1], [7,1], [6,6], [6,7], [7,6]];
                if (adjacentToCorner.some(([r, c]) => r === row && c === col)) score -= 20;
                
                const opponentMoves = findValidMoves(newBoard, 'black');
                score -= opponentMoves.length * 2;
                
                if (row === 0 || row === 7 || col === 0 || col === 7) score += 5;
                
                if (score > bestScore) {
                  bestScore = score;
                  bestMove = [row, col];
                }
              }
              
              if (bestMove) {
                setTimeout(() => makeMove(bestMove[0], bestMove[1], 'white'), 1000);
              }
              return;
            }

            if (!useAI || !apiKey || aiStatus !== 'connected') {
              // Fallback to simple AI
              makeSimpleAIMove();
              return;
            }

            const moves = findValidMoves(board, 'white');
            if (moves.length === 0) return;

            setAiThinking(true);

            try {
              // Convert board to string representation
              const boardStr = board.map((row, i) => 
                row.map((cell, j) => {
                  if (cell === 'black') return 'B';
                  if (cell === 'white') return 'W';
                  return '.';
                }).join(' ')
              ).join('\n');

              const validMovesStr = moves.map(([r, c]) => `(${r},${c})`).join(', ');

              const prompt = `You are playing Othello/Reversi as White at ${difficulty} difficulty level. Analyze this board position and choose the best move.

Current board (B=Black, W=White, .=Empty):
${boardStr}

Your valid moves: ${validMovesStr}

Difficulty level: ${difficulty}
${difficulty === 'easy' ? '- Play more casually, prioritize immediate captures' :
  difficulty === 'medium' ? '- Balance immediate gains with basic strategy' :
  difficulty === 'hard' ? '- Use advanced strategy, consider mobility and stability' :
  '- Play at expert level with deep strategic thinking'}

Consider:
- Corner control (positions 0,0 / 0,7 / 7,0 / 7,7)
- Edge control and stability
- Mobility (limiting opponent's options)
- Avoiding moves that give opponent corners
- Current material advantage
${difficulty === 'hard' || difficulty === 'expert' ? '- Long-term positional advantages' : ''}

Respond with just the coordinates in format: row,col (e.g., "3,2")`;

              const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': apiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-3-haiku-20240307',
                  max_tokens: 50,
                  messages: [{
                    role: 'user',
                    content: prompt
                  }]
                })
              });

              if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                setAiStatus('error');
                setAiError(errorData.error?.message || `HTTP ${response.status}`);
                throw new Error(`API Error: ${response.status}`);
              }

              const data = await response.json();
              const moveText = data.content[0].text.trim();
              
              // Parse the move
              const match = moveText.match(/(\d+),(\d+)/);
              if (match) {
                const row = parseInt(match[1]);
                const col = parseInt(match[2]);
                
                // Validate the move
                if (moves.some(([r, c]) => r === row && c === col)) {
                  setTimeout(() => {
                    makeMove(row, col, 'white');
                    setAiThinking(false);
                  }, 500);
                  return;
                }
              }
              
              // Fallback if parsing failed
              console.log('Move parsing failed, using simple AI');
              makeSimpleAIMove();
            } catch (error) {
              console.error('AI move failed:', error);
              makeSimpleAIMove();
            }
            
            setAiThinking(false);
          }, [board, findValidMoves, makeMove, apiKey, useAI, aiStatus, makeSimpleAIMove, difficulty]);

          // Handle cell click (human moves only)
          const handleCellClick = (row, col) => {
            if (gameOver || currentPlayer !== 'black') return;
            makeMove(row, col, 'black');
          };

          // Reset game
          const resetGame = () => {
            setBoard(initializeBoard());
            setCurrentPlayer('black');
            setGameOver(false);
            setValidMoves([]);
            setScores({ black: 2, white: 2 });
            setAiThinking(false);
            setAiError('');
          };

          // Check if a cell is a valid move
          const isValidMove = (row, col) => {
            return validMoves.some(([r, c]) => r === row && c === col);
          };

          // Status indicator component
          const StatusIndicator = ({ status, error }) => {
            const statusConfig = {
              disconnected: { color: 'text-gray-500', bg: 'bg-gray-100', icon: '⚪', text: 'Disconnected' },
              connecting: { color: 'text-yellow-600', bg: 'bg-yellow-100', icon: '🔄', text: 'Connecting...' },
              connected: { color: 'text-green-600', bg: 'bg-green-100', icon: '✅', text: 'Connected' },
              error: { color: 'text-red-600', bg: 'bg-red-100', icon: '❌', text: 'Error' }
            };

            const config = statusConfig[status] || statusConfig.disconnected;

            return React.createElement('div', {
              className: `flex items-center gap-2 px-3 py-2 rounded-lg ${config.bg}`
            }, [
              React.createElement('span', { className: 'text-sm', key: 'icon' }, config.icon),
              React.createElement('div', { className: 'flex-1', key: 'content' }, [
                React.createElement('div', {
                  className: `text-sm font-semibold ${config.color}`,
                  key: 'text'
                }, `Claude AI: ${config.text}`),
                error && React.createElement('div', {
                  className: 'text-xs text-red-500 mt-1 break-words',
                  key: 'error'
                }, error)
              ])
            ]);
          };

          // Update valid moves when board or player changes
          React.useEffect(() => {
            const moves = findValidMoves(board, currentPlayer);
            setValidMoves(moves);
            setScores(calculateScores(board));

            // Check if game is over
            if (moves.length === 0) {
              const opponentMoves = findValidMoves(board, currentPlayer === 'black' ? 'white' : 'black');
              if (opponentMoves.length === 0) {
                setGameOver(true);
              } else {
                // Current player has no moves, switch to opponent
                setCurrentPlayer(currentPlayer === 'black' ? 'white' : 'black');
              }
            } else if (currentPlayer === 'white' && !gameOver) {
              // Auto-play AI moves - do this here to avoid duplicate effects
              makeAIMove();
            }
          }, [board, currentPlayer, findValidMoves, calculateScores, gameOver, makeAIMove]);

          // Test connection when API key changes
          React.useEffect(() => {
            if (useAI && apiKey) {
              const timeoutId = setTimeout(testAPIConnection, 500); // Debounce API calls
              return () => clearTimeout(timeoutId);
            } else {
              setAiStatus('disconnected');
              setAiError('');
            }
          }, [apiKey, useAI, testAPIConnection]);

          return (
            React.createElement('div', {
              className: 'flex flex-col items-center p-6 bg-green-800 min-h-screen'
            }, [
              React.createElement('h1', {
                className: 'text-3xl font-bold text-white mb-6',
                key: 'title'
              }, 'Othello / Reversi'),
              
              // AI Controls
              React.createElement('div', {
                className: 'bg-white p-4 rounded-lg mb-4 shadow-lg w-full max-w-md',
                key: 'ai-controls'
              }, [
                React.createElement('div', { className: 'mb-3', key: 'ai-toggle' }, 
                  React.createElement('label', { className: 'flex items-center gap-2', key: 'ai-label' }, [
                    React.createElement('input', {
                      type: 'checkbox',
                      checked: useAI,
                      onChange: (e) => setUseAI(e.target.checked),
                      className: 'w-4 h-4',
                      key: 'checkbox'
                    }),
                    React.createElement('span', {
                      className: 'font-semibold',
                      key: 'label'
                    }, 'Use Claude AI (requires API key)')
                  ])
                ),

                // Difficulty Selection
                React.createElement('div', { className: 'mb-3', key: 'difficulty' }, [
                  React.createElement('label', {
                    className: 'block text-sm font-semibold mb-2',
                    key: 'diff-label'
                  }, 'Difficulty Level:'),
                  React.createElement('select', {
                    value: difficulty,
                    onChange: (e) => setDifficulty(e.target.value),
                    className: 'w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500',
                    key: 'diff-select'
                  }, [
                    React.createElement('option', { value: 'easy', key: 'easy' }, '🟢 Easy - Random moves with slight strategy'),
                    React.createElement('option', { value: 'medium', key: 'medium' }, '🟡 Medium - Basic corner and edge strategy'),
                    React.createElement('option', { value: 'hard', key: 'hard' }, '🔴 Hard - Advanced strategy with mobility'),
                    React.createElement('option', { value: 'expert', key: 'expert' }, '⚫ Expert - Claude AI only (requires API key)')
                  ]),
                  (difficulty === 'expert' && !useAI) ? React.createElement('div', {
                    className: 'text-sm text-orange-600 mt-1',
                    key: 'expert-warning'
                  }, 'Expert difficulty requires Claude AI to be enabled') : null
                ]),
                
                useAI ? React.createElement('div', { className: 'space-y-3', key: 'ai-settings' }, [
                  React.createElement('div', { key: 'api-input' }, [
                    React.createElement('input', {
                      type: 'password',
                      placeholder: 'Enter your Anthropic API key',
                      value: apiKey,
                      onChange: (e) => setApiKey(e.target.value),
                      className: 'w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500',
                      key: 'input'
                    }),
                    React.createElement('div', {
                      className: 'text-xs text-gray-500 mt-1',
                      key: 'help'
                    }, 'Your API key is only used locally and not stored')
                  ]),
                  
                  React.createElement(StatusIndicator, {
                    status: aiStatus,
                    error: aiError,
                    key: 'status'
                  })
                ]) : null,
                
                aiThinking ? React.createElement('div', {
                  className: 'text-center text-blue-600 font-semibold mt-3',
                  key: 'thinking'
                }, '🤔 Claude is thinking...') : null
              ]),

              // Game Info
              React.createElement('div', {
                className: 'bg-white p-4 rounded-lg mb-4 shadow-lg',
                key: 'game-info'
              }, [
                React.createElement('div', {
                  className: 'flex items-center gap-6 mb-2',
                  key: 'scores'
                }, [
                  React.createElement('div', {
                    className: 'flex items-center gap-2',
                    key: 'black-score'
                  }, [
                    React.createElement('div', {
                      className: 'w-6 h-6 bg-black rounded-full border-2 border-gray-400',
                      key: 'black-piece'
                    }),
                    React.createElement('span', {
                      className: 'font-semibold',
                      key: 'black-text'
                    }, `Black: ${scores.black}`)
                  ]),
                  React.createElement('div', {
                    className: 'flex items-center gap-2',
                    key: 'white-score'
                  }, [
                    React.createElement('div', {
                      className: 'w-6 h-6 bg-white rounded-full border-2 border-gray-400',
                      key: 'white-piece'
                    }),
                    React.createElement('span', {
                      className: 'font-semibold',
                      key: 'white-text'
                    }, `White: ${scores.white}`)
                  ])
                ]),
                
                !gameOver ? React.createElement('div', {
                  className: 'text-center',
                  key: 'turn-info'
                }, [
                  React.createElement('span', {
                    className: 'font-semibold',
                    key: 'turn-label'
                  }, 'Current turn: '),
                  React.createElement('span', {
                    className: `font-bold ${currentPlayer === 'black' ? 'text-black' : 'text-gray-600'}`,
                    key: 'current-player'
                  }, currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)),
                  (currentPlayer === 'black') ? React.createElement('span', {
                    className: 'text-sm text-gray-600 ml-2',
                    key: 'you'
                  }, '(You)') : null,
                  (currentPlayer === 'white' && !useAI) ? React.createElement('span', {
                    className: 'text-sm text-gray-600 ml-2',
                    key: 'ai-simple'
                  }, `(${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} AI)`) : null,
                  (currentPlayer === 'white' && useAI) ? React.createElement('span', {
                    className: 'text-sm text-gray-600 ml-2',
                    key: 'ai-claude'
                  }, `(Claude AI - ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)})`) : null
                ]) : React.createElement('div', {
                  className: 'text-center',
                  key: 'game-over'
                }, [
                  React.createElement('div', {
                    className: 'font-bold text-lg mb-2',
                    key: 'game-over-text'
                  }, 'Game Over!'),
                  React.createElement('div', {
                    className: 'font-semibold',
                    key: 'winner'
                  }, scores.black > scores.white ? 'Black Wins!' : 
                     scores.white > scores.black ? 'White Wins!' : 'Tie Game!')
                ])
              ]),

              // Game Board
              React.createElement('div', {
                className: 'grid grid-cols-8 gap-1 bg-black p-2 rounded-lg shadow-2xl',
                key: 'board'
              }, board.flatMap((row, rowIndex) =>
                row.map((cell, colIndex) => (
                  React.createElement('div', {
                    key: `cell-${rowIndex}-${colIndex}`,
                    className: 'w-12 h-12 bg-green-600 border border-green-700 flex items-center justify-center cursor-pointer hover:bg-green-500',
                    onClick: () => handleCellClick(rowIndex, colIndex)
                  }, 
                    cell ? React.createElement('div', {
                      className: `w-10 h-10 rounded-full border-2 border-gray-400 shadow-lg ${cell === 'black' ? 'bg-black' : 'bg-white'}`,
                      key: 'piece'
                    }) : null
                  )
                ))
              )),

              // Controls
              React.createElement('button', {
                onClick: resetGame,
                className: 'mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-semibold',
                key: 'reset'
              }, 'New Game'),

              // Instructions
              React.createElement('div', {
                className: 'mt-4 text-white text-sm max-w-md text-center',
                key: 'instructions'
              }, [
                React.createElement('p', {
                  className: 'mb-2',
                  key: 'inst1'
                }, 'You are Black and go first. Click on any empty square to attempt your move.'),
                React.createElement('p', {
                  key: 'inst2'
                }, 'Capture your opponent\'s pieces by placing your piece so that opponent pieces are trapped between your pieces in any direction (horizontal, vertical, or diagonal).')
              ])
            ])
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(OthelloGame));
    </script>
</body>
</html>

